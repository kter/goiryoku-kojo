{
  "version": 4,
  "terraform_version": "1.14.3",
  "serial": 111,
  "lineage": "c7535d9c-5889-c168-cb1a-41a4ea1fc0ab",
  "outputs": {
    "generate_words_url": {
      "value": "https://generate-words-cqiy6alq3a-an.a.run.app",
      "type": "string"
    },
    "get_words_url": {
      "value": "https://get-words-cqiy6alq3a-an.a.run.app",
      "type": "string"
    },
    "score_answers_url": {
      "value": "https://score-answers-cqiy6alq3a-an.a.run.app",
      "type": "string"
    },
    "service_account_email": {
      "value": "goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
      "type": "string"
    }
  },
  "resources": [
    {
      "mode": "data",
      "type": "archive_file",
      "name": "generate_words_source",
      "provider": "provider[\"registry.terraform.io/hashicorp/archive\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "exclude_symlink_directories": null,
            "excludes": null,
            "id": "e88aa667e9ee1bf7342b9fb0455fca58ae46bc95",
            "output_base64sha256": "EX4SGXM9tiEJEYPnWu2TVU7doGFLovW8bu2Al0VnMG4=",
            "output_base64sha512": "KKveycCW/ejJ06KkXDGvo1RMuZv7F1HKr0GMkbPqMlLRoR98W96oRocYqsQkpyZu8aRdsiJ0VgwFIvu5uZPMYQ==",
            "output_file_mode": null,
            "output_md5": "11780625523fd42e15118f3d28dc5457",
            "output_path": "./tmp/generate_words.zip",
            "output_sha": "e88aa667e9ee1bf7342b9fb0455fca58ae46bc95",
            "output_sha256": "117e1219733db621091183e75aed93554edda0614ba2f5bc6eed80974567306e",
            "output_sha512": "28abdec9c096fde8c9d3a2a45c31afa3544cb99bfb1751caaf418c91b3ea3252d1a11f7c5bdea8468718aac424a7266ef1a45db22274560c0522fbb9b993cc61",
            "output_size": 7348,
            "source": [
              {
                "content": "# Shared utilities for Cloud Functions\n",
                "filename": "__init__.py"
              },
              {
                "content": "\"\"\"Batch function to generate vocabulary words using Gemini 1.5 Flash.\"\"\"\n\nimport logging\nimport os\nimport traceback\nfrom datetime import date, timedelta\nfrom http import HTTPStatus\n\nimport functions_framework\nfrom flask import Request, Response\n\n# In Cloud Functions, all source files are bundled in the same directory\nfrom firestore_client import FirestoreClient\nfrom gemini_client import GeminiClient, GeminiClientError\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Get project ID from environment variable\nPROJECT_ID = os.environ.get(\"GCP_PROJECT\")\n\n\ndef get_missing_dates(\n    firestore_client: FirestoreClient,\n    start_date: date,\n    end_date: date\n) -\u003e list[str]:\n    \"\"\"Find dates that don't have words generated yet.\n    \n    Args:\n        firestore_client: Firestore client instance.\n        start_date: Start date (inclusive).\n        end_date: End date (inclusive).\n        \n    Returns:\n        List of missing date strings (YYYY-MM-DD).\n    \"\"\"\n    existing_dates = firestore_client.get_existing_dates(start_date, end_date)\n    \n    missing_dates = []\n    current = start_date\n    while current \u003c= end_date:\n        date_str = current.isoformat()\n        if date_str not in existing_dates:\n            missing_dates.append(date_str)\n        current += timedelta(days=1)\n    \n    return missing_dates\n\n\n@functions_framework.http\ndef generate_words(request: Request) -\u003e Response:\n    \"\"\"HTTP Cloud Function to generate vocabulary words.\n    \n    Triggered by Cloud Scheduler daily at 0:00 JST.\n    Generates words for any missing dates in the next 7 days.\n    \n    Args:\n        request: Flask request object.\n        \n    Returns:\n        JSON response with generation results.\n    \"\"\"\n    try:\n        logger.info(f\"Starting generate_words function. PROJECT_ID={PROJECT_ID}\")\n        \n        # Initialize clients with explicit project ID\n        firestore_client = FirestoreClient(project_id=PROJECT_ID)\n        gemini_client = GeminiClient(project_id=PROJECT_ID)\n        \n        # Define date range: today to 7 days ahead\n        today = date.today()\n        end_date = today + timedelta(days=7)\n        \n        # Find missing dates\n        missing_dates = get_missing_dates(firestore_client, today, end_date)\n        \n        if not missing_dates:\n            logger.info(\"No missing dates found. Skipping generation.\")\n            return Response(\n                '{\"success\": true, \"message\": \"No generation needed\", \"generated\": 0}',\n                status=HTTPStatus.OK,\n                mimetype=\"application/json\"\n            )\n        \n        logger.info(f\"Generating words for {len(missing_dates)} dates: {missing_dates}\")\n        \n        # Get recent words to avoid duplication\n        recent_words = firestore_client.get_recent_words(days=10)\n        recent_word_list = [w[\"word\"] for w in recent_words]\n        \n        logger.info(f\"Recent words to avoid: {recent_word_list}\")\n        \n        # Generate words using Gemini\n        generated_words = gemini_client.generate_words(\n            dates=missing_dates,\n            recent_words=recent_word_list\n        )\n        \n        if not generated_words:\n            logger.warning(\"No words generated from Gemini\")\n            return Response(\n                '{\"success\": false, \"error\": \"No words generated\", \"generated\": 0}',\n                status=HTTPStatus.INTERNAL_SERVER_ERROR,\n                mimetype=\"application/json\"\n            )\n        \n        # Save to Firestore\n        saved_count = firestore_client.save_words(generated_words)\n        \n        logger.info(f\"Successfully generated and saved {saved_count} words\")\n        \n        return Response(\n            f'{{\"success\": true, \"generated\": {saved_count}, \"dates\": {missing_dates}}}',\n            status=HTTPStatus.OK,\n            mimetype=\"application/json\"\n        )\n        \n    except GeminiClientError as e:\n        logger.error(f\"Gemini API error: {e}\")\n        logger.error(traceback.format_exc())\n        return Response(\n            f'{{\"success\": false, \"error\": \"AI generation failed: {str(e)}\"}}',\n            status=HTTPStatus.INTERNAL_SERVER_ERROR,\n            mimetype=\"application/json\"\n        )\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\")\n        logger.error(traceback.format_exc())\n        return Response(\n            f'{{\"success\": false, \"error\": \"Internal server error: {str(e)}\"}}',\n            status=HTTPStatus.INTERNAL_SERVER_ERROR,\n            mimetype=\"application/json\"\n        )\n",
                "filename": "main.py"
              },
              {
                "content": "\"\"\"Firestore client for vocabulary words management.\"\"\"\n\nfrom datetime import date, timedelta\nfrom typing import Optional\nfrom google.cloud import firestore\n\n\nclass FirestoreClient:\n    \"\"\"Client for interacting with Firestore to manage vocabulary words.\"\"\"\n\n    COLLECTION_NAME = \"words\"\n\n    def __init__(self, project_id: Optional[str] = None):\n        \"\"\"Initialize Firestore client.\n        \n        Args:\n            project_id: Optional GCP project ID. If None, uses default.\n        \"\"\"\n        if project_id:\n            self._db = firestore.Client(project=project_id)\n        else:\n            self._db = firestore.Client()\n\n    def get_words_by_date_range(\n        self, start_date: date, end_date: date\n    ) -\u003e list[dict]:\n        \"\"\"Get words within a date range.\n        \n        Args:\n            start_date: Start date (inclusive).\n            end_date: End date (inclusive).\n            \n        Returns:\n            List of word documents found within the range.\n            Missing dates are simply not included (no error).\n        \"\"\"\n        start_str = start_date.isoformat()\n        end_str = end_date.isoformat()\n\n        docs = (\n            self._db.collection(self.COLLECTION_NAME)\n            .where(\"date\", \"\u003e=\", start_str)\n            .where(\"date\", \"\u003c=\", end_str)\n            .order_by(\"date\")\n            .stream()\n        )\n\n        return [doc.to_dict() for doc in docs]\n\n    def get_recent_words(self, days: int = 10) -\u003e list[dict]:\n        \"\"\"Get words from the last N days.\n        \n        Args:\n            days: Number of days to look back.\n            \n        Returns:\n            List of recent word documents.\n        \"\"\"\n        end_date = date.today()\n        start_date = end_date - timedelta(days=days)\n        return self.get_words_by_date_range(start_date, end_date)\n\n    def get_existing_dates(\n        self, start_date: date, end_date: date\n    ) -\u003e set[str]:\n        \"\"\"Get set of dates that already have words.\n        \n        Args:\n            start_date: Start date (inclusive).\n            end_date: End date (inclusive).\n            \n        Returns:\n            Set of date strings (YYYY-MM-DD) that exist.\n        \"\"\"\n        words = self.get_words_by_date_range(start_date, end_date)\n        return {word[\"date\"] for word in words}\n\n    def save_words(self, words: list[dict]) -\u003e int:\n        \"\"\"Save generated words to Firestore.\n        \n        Args:\n            words: List of word dictionaries with 'date', 'word', 'reading', 'word_en' keys.\n            \n        Returns:\n            Number of words saved.\n        \"\"\"\n        batch = self._db.batch()\n        count = 0\n\n        for word in words:\n            # Use date as document ID for easy lookup and deduplication\n            doc_ref = self._db.collection(self.COLLECTION_NAME).document(\n                word[\"date\"]\n            )\n            batch.set(doc_ref, word)\n            count += 1\n\n        batch.commit()\n        return count\n\n    def get_word_by_date(self, target_date: date) -\u003e Optional[dict]:\n        \"\"\"Get a single word by date.\n        \n        Args:\n            target_date: The date to look up.\n            \n        Returns:\n            Word document if found, None otherwise.\n        \"\"\"\n        doc_ref = self._db.collection(self.COLLECTION_NAME).document(\n            target_date.isoformat()\n        )\n        doc = doc_ref.get()\n\n        if doc.exists:\n            return doc.to_dict()\n        return None\n",
                "filename": "firestore_client.py"
              },
              {
                "content": "\"\"\"Gemini client for vocabulary word generation using Vertex AI.\"\"\"\n\nimport json\nimport logging\nfrom typing import Optional\n\nimport vertexai\nfrom vertexai.generative_models import GenerativeModel, GenerationConfig\n\nlogger = logging.getLogger(__name__)\n\n\nclass GeminiClientError(Exception):\n    \"\"\"Base exception for Gemini client errors.\"\"\"\n    pass\n\n\nclass GeminiParseError(GeminiClientError):\n    \"\"\"Raised when response cannot be parsed as expected JSON.\"\"\"\n    pass\n\n\nclass GeminiClient:\n    \"\"\"Client for generating vocabulary words using Gemini 2.5 Flash.\"\"\"\n\n    MODEL_NAME = \"gemini-2.5-flash\"\n    \n    SYSTEM_PROMPT = \"\"\"あなたは日本語の語彙力トレーニングアプリのための単語生成AIです。\n\nあなたの役割は、指定された日付に対して抽象的で少し難しい日本語の名詞を生成し、その英訳も提供することです。\n\n## 出力ルール\n- 必ず以下のJSON形式のみで出力してください。説明文や追加のテキストは一切含めないでください。\n- 各単語は「word」(漢字表記)、「reading」(ひらがな読み)、「word_en」(英語訳)を含めてください。\n\n## JSON形式\n{\n  \"words\": [\n    {\n      \"date\": \"YYYY-MM-DD\",\n      \"word\": \"単語\",\n      \"reading\": \"たんご\",\n      \"word_en\": \"English translation\"\n    }\n  ]\n}\n\n## 単語選定基準\n- 抽象的な概念を表す名詞を選ぶこと\n- 日常会話ではあまり使われないが、知っていると語彙力が高いと感じられる単語\n- 小学校高学年〜中学生レベルの漢字で構成される単語\n- 例: 概念(concept)、帰結(consequence)、矛盾(contradiction)、逆説(paradox)、恩恵(blessing)\"\"\"\n\n    def __init__(\n        self,\n        project_id: Optional[str] = None,\n        location: str = \"asia-northeast1\"\n    ):\n        \"\"\"Initialize Gemini client.\n        \n        Args:\n            project_id: GCP project ID.\n            location: Vertex AI location.\n        \"\"\"\n        vertexai.init(project=project_id, location=location)\n        self._model = GenerativeModel(\n            self.MODEL_NAME,\n            system_instruction=self.SYSTEM_PROMPT\n        )\n        self._generation_config = GenerationConfig(\n            temperature=0.8,\n            max_output_tokens=8192,\n            response_mime_type=\"application/json\"\n        )\n\n    def generate_words(\n        self,\n        dates: list[str],\n        recent_words: list[str]\n    ) -\u003e list[dict]:\n        \"\"\"Generate vocabulary words for specified dates.\n        \n        Args:\n            dates: List of date strings (YYYY-MM-DD) to generate words for.\n            recent_words: List of recent words to avoid duplication.\n            \n        Returns:\n            List of generated word dictionaries.\n            \n        Raises:\n            GeminiParseError: If response cannot be parsed.\n            GeminiClientError: For other API errors.\n        \"\"\"\n        if not dates:\n            return []\n\n        # Build prompt with context\n        recent_words_str = \"、\".join(recent_words) if recent_words else \"なし\"\n        dates_str = \", \".join(dates)\n        \n        prompt = f\"\"\"以下の日付に対して、それぞれ1つずつ抽象的で少し難しい日本語の名詞を生成してください。\n\n対象日付: {dates_str}\n\n## 重複回避\n以下の直近の単語とは重複しない単語を選んでください:\n{recent_words_str}\n\n上記の形式で、{len(dates)}件の単語をJSON形式で出力してください。\"\"\"\n\n        try:\n            response = self._model.generate_content(\n                prompt,\n                generation_config=self._generation_config\n            )\n            \n            return self._parse_response(response.text)\n            \n        except json.JSONDecodeError as e:\n            logger.error(f\"Failed to parse Gemini response: {e}\")\n            raise GeminiParseError(f\"Invalid JSON response: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Gemini API error: {e}\")\n            raise GeminiClientError(f\"API error: {e}\") from e\n\n    def _parse_response(self, response_text: str) -\u003e list[dict]:\n        \"\"\"Parse and validate the JSON response.\n        \n        Args:\n            response_text: Raw response text from Gemini.\n            \n        Returns:\n            List of validated word dictionaries.\n            \n        Raises:\n            GeminiParseError: If parsing or validation fails.\n        \"\"\"\n        try:\n            # Clean response text (remove markdown code blocks if present)\n            cleaned = response_text.strip()\n            if cleaned.startswith(\"```json\"):\n                cleaned = cleaned[7:]\n            if cleaned.startswith(\"```\"):\n                cleaned = cleaned[3:]\n            if cleaned.endswith(\"```\"):\n                cleaned = cleaned[:-3]\n            cleaned = cleaned.strip()\n\n            data = json.loads(cleaned)\n            \n            if \"words\" not in data:\n                raise GeminiParseError(\"Response missing 'words' key\")\n            \n            words = data[\"words\"]\n            validated_words = []\n            \n            for word in words:\n                if not all(k in word for k in [\"date\", \"word\", \"reading\", \"word_en\"]):\n                    logger.warning(f\"Skipping invalid word entry: {word}\")\n                    continue\n                validated_words.append({\n                    \"date\": word[\"date\"],\n                    \"word\": word[\"word\"],\n                    \"reading\": word[\"reading\"],\n                    \"word_en\": word[\"word_en\"]\n                })\n            \n            return validated_words\n            \n            return validated_words\n            \n        except json.JSONDecodeError as e:\n            raise GeminiParseError(f\"Failed to parse JSON: {e}\") from e\n\n    def score_answers(\n        self,\n        word: str,\n        answers: list[str],\n        game_type: str,\n        locale: str = \"ja\",\n    ) -\u003e dict:\n        \"\"\"Score user answers for vocabulary game.\n        \n        Args:\n            word: The target word (お題).\n            answers: List of user's answers.\n            game_type: \"word_replacement\" or \"rhyming\".\n            locale: Language for prompts (\"ja\" or \"en\").\n            \n        Returns:\n            Dictionary with score (0-100) and feedback.\n            \n        Raises:\n            GeminiClientError: For API errors.\n        \"\"\"\n        is_english = locale == \"en\"\n        game_context = self._get_game_context(game_type, is_english)\n        \n        if is_english:\n            system_prompt = f\"\"\"You are a linguistics expert. Score the user's word list against the given topic using the following criteria, and return your response in JSON format.\n\nEvaluation Criteria:\n{game_context}\n\nResponse Format (must return in this exact JSON format):\n{{\n  \"score\": \u003cinteger from 0-100\u003e,\n  \"feedback\": \"\u003cfeedback in English including scoring reasons and suggestions for improvement\u003e\"\n}}\n\nScoring Guidelines:\n- Each word is worth up to 10 points\n- Score up to 10 words maximum (100 points total)\n- Duplicate words are not scored\n- Inappropriate or irrelevant words score 0\n- Evaluate creativity and vocabulary richness\"\"\"\n        else:\n            system_prompt = f\"\"\"あなたは言語学の専門家です。提示された『お題』に対して、ユーザーが入力した『単語リスト』を以下の基準で採点し、JSON形式で返してください。\n\n評価基準：\n{game_context}\n\n回答形式（必ずこの形式のJSONで返してください）：\n{{\n  \"score\": \u003c0-100の整数\u003e,\n  \"feedback\": \"\u003c採点理由と改善点を含む日本語のフィードバック\u003e\"\n}}\n\n採点のポイント：\n- 各単語は最大10点\n- 最大10単語まで採点（100点満点）\n- 重複した単語は採点しない\n- 不適切または無関係な単語は0点\n- 創造性と語彙力の豊かさを評価\"\"\"\n\n        if is_english:\n            game_type_name = \"Word Replacement\" if game_type == \"word_replacement\" else \"Rhyming\"\n            answers_text = \"\\n\".join(f\"• {a}\" for a in answers) if answers else \"(No answers)\"\n            user_prompt = f\"\"\"【Game Type】{game_type_name}\n\n【Topic】{word}\n\n【User's Answers】\n{answers_text}\n\nPlease score the above answers.\"\"\"\n        else:\n            game_type_name = \"言葉の置き換え\" if game_type == \"word_replacement\" else \"韻を踏む\"\n            answers_text = \"\\n\".join(f\"・{a}\" for a in answers) if answers else \"（回答なし）\"\n            user_prompt = f\"\"\"【ゲーム種別】{game_type_name}\n\n【お題】{word}\n\n【ユーザーの回答】\n{answers_text}\n\n上記の回答を採点してください。\"\"\"\n\n        try:\n            model = GenerativeModel(\n                self.MODEL_NAME,\n                system_instruction=system_prompt,\n            )\n            \n            config = GenerationConfig(\n                temperature=0.7,\n                max_output_tokens=8192,\n                response_mime_type=\"application/json\",\n            )\n            \n            response = model.generate_content(user_prompt, generation_config=config)\n            return self._parse_score_response(response.text)\n            \n        except Exception as e:\n            logger.error(f\"Gemini API error during scoring: {e}\")\n            raise GeminiClientError(f\"Scoring API error: {e}\") from e\n\n    def _get_game_context(self, game_type: str, is_english: bool = False) -\u003e str:\n        \"\"\"Get evaluation context for the game type.\"\"\"\n        if game_type == \"word_replacement\":\n            if is_english:\n                return \"\"\"【Word Replacement Game】\n- Evaluate words with the same or similar meaning to the topic word\n- Priority on appropriateness as synonyms\n- Higher scores for more refined expressions or specialized alternatives\"\"\"\n            else:\n                return \"\"\"【言葉の置き換えゲーム】\n- お題の単語と同じ意味、または類似の意味を持つ単語を評価\n- 同義語、類義語としての適切さを重視\n- より洗練された表現や専門的な言い換えは高得点\"\"\"\n        else:\n            if is_english:\n                return \"\"\"【Rhyming Game】\n- Evaluate whether words rhyme with the topic (matching end sounds)\n- Evaluate not just sound matching but also cleverness of the word\n- Higher scores for creative and unexpected rhymes\"\"\"\n            else:\n                return \"\"\"【韻を踏むゲーム】\n- お題の単語と韻を踏んでいるか（語尾の音が一致しているか）を評価\n- 単なる音の一致だけでなく、言葉としての面白さも評価\n- 創造的で意外性のある韻は高得点\"\"\"\n\n    def _parse_score_response(self, response_text: str) -\u003e dict:\n        \"\"\"Parse the scoring response.\"\"\"\n        try:\n            cleaned = response_text.strip()\n            if cleaned.startswith(\"```json\"):\n                cleaned = cleaned[7:]\n            if cleaned.startswith(\"```\"):\n                cleaned = cleaned[3:]\n            if cleaned.endswith(\"```\"):\n                cleaned = cleaned[:-3]\n            cleaned = cleaned.strip()\n            \n            data = json.loads(cleaned)\n            \n            return {\n                \"score\": int(data.get(\"score\", 0)),\n                \"feedback\": str(data.get(\"feedback\", \"\")),\n            }\n            \n        except (json.JSONDecodeError, ValueError) as e:\n            logger.error(f\"Failed to parse score response: {e}\")\n            return {\n                \"score\": 0,\n                \"feedback\": \"スコアの解析に失敗しました。\",\n            }\n\n",
                "filename": "gemini_client.py"
              },
              {
                "content": "functions-framework==3.*\ngoogle-cloud-firestore\u003e=2.14.0\ngoogle-cloud-aiplatform\u003e=1.38.0\nflask\u003e=2.0.0\n",
                "filename": "requirements.txt"
              }
            ],
            "source_content": null,
            "source_content_filename": null,
            "source_dir": null,
            "source_file": null,
            "type": "zip"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0
        }
      ]
    },
    {
      "mode": "data",
      "type": "archive_file",
      "name": "get_words_source",
      "provider": "provider[\"registry.terraform.io/hashicorp/archive\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "exclude_symlink_directories": null,
            "excludes": null,
            "id": "ab6815372f3f34374ab37df027cc9be5f4d6a0dd",
            "output_base64sha256": "swxPw7Hli6YSwSk1diQ8P4RbRCJco3uTLeEqwrtsIAU=",
            "output_base64sha512": "lhGgAHLhg6FUT4SzWu0crjssXfP815byze/ycK3hvICoZGtN9a21OxfNSGycMgs2cByTNUPm4exlaaEhlOM+ZA==",
            "output_file_mode": null,
            "output_md5": "b17ce43f85e4ee00e230a72e46fbc68f",
            "output_path": "./tmp/get_words.zip",
            "output_sha": "ab6815372f3f34374ab37df027cc9be5f4d6a0dd",
            "output_sha256": "b30c4fc3b1e58ba612c1293576243c3f845b44225ca37b932de12ac2bb6c2005",
            "output_sha512": "9611a00072e183a1544f84b35aed1cae3b2c5df3fcd796f2cdeff270ade1bc80a8646b4df5adb53b17cd486c9c320b36701c933543e6e1ec6569a12194e33e64",
            "output_size": 2899,
            "source": [
              {
                "content": "# Shared utilities for Cloud Functions\n",
                "filename": "__init__.py"
              },
              {
                "content": "\"\"\"Firestore client for vocabulary words management.\"\"\"\n\nfrom datetime import date, timedelta\nfrom typing import Optional\nfrom google.cloud import firestore\n\n\nclass FirestoreClient:\n    \"\"\"Client for interacting with Firestore to manage vocabulary words.\"\"\"\n\n    COLLECTION_NAME = \"words\"\n\n    def __init__(self, project_id: Optional[str] = None):\n        \"\"\"Initialize Firestore client.\n        \n        Args:\n            project_id: Optional GCP project ID. If None, uses default.\n        \"\"\"\n        if project_id:\n            self._db = firestore.Client(project=project_id)\n        else:\n            self._db = firestore.Client()\n\n    def get_words_by_date_range(\n        self, start_date: date, end_date: date\n    ) -\u003e list[dict]:\n        \"\"\"Get words within a date range.\n        \n        Args:\n            start_date: Start date (inclusive).\n            end_date: End date (inclusive).\n            \n        Returns:\n            List of word documents found within the range.\n            Missing dates are simply not included (no error).\n        \"\"\"\n        start_str = start_date.isoformat()\n        end_str = end_date.isoformat()\n\n        docs = (\n            self._db.collection(self.COLLECTION_NAME)\n            .where(\"date\", \"\u003e=\", start_str)\n            .where(\"date\", \"\u003c=\", end_str)\n            .order_by(\"date\")\n            .stream()\n        )\n\n        return [doc.to_dict() for doc in docs]\n\n    def get_recent_words(self, days: int = 10) -\u003e list[dict]:\n        \"\"\"Get words from the last N days.\n        \n        Args:\n            days: Number of days to look back.\n            \n        Returns:\n            List of recent word documents.\n        \"\"\"\n        end_date = date.today()\n        start_date = end_date - timedelta(days=days)\n        return self.get_words_by_date_range(start_date, end_date)\n\n    def get_existing_dates(\n        self, start_date: date, end_date: date\n    ) -\u003e set[str]:\n        \"\"\"Get set of dates that already have words.\n        \n        Args:\n            start_date: Start date (inclusive).\n            end_date: End date (inclusive).\n            \n        Returns:\n            Set of date strings (YYYY-MM-DD) that exist.\n        \"\"\"\n        words = self.get_words_by_date_range(start_date, end_date)\n        return {word[\"date\"] for word in words}\n\n    def save_words(self, words: list[dict]) -\u003e int:\n        \"\"\"Save generated words to Firestore.\n        \n        Args:\n            words: List of word dictionaries with 'date', 'word', 'reading', 'word_en' keys.\n            \n        Returns:\n            Number of words saved.\n        \"\"\"\n        batch = self._db.batch()\n        count = 0\n\n        for word in words:\n            # Use date as document ID for easy lookup and deduplication\n            doc_ref = self._db.collection(self.COLLECTION_NAME).document(\n                word[\"date\"]\n            )\n            batch.set(doc_ref, word)\n            count += 1\n\n        batch.commit()\n        return count\n\n    def get_word_by_date(self, target_date: date) -\u003e Optional[dict]:\n        \"\"\"Get a single word by date.\n        \n        Args:\n            target_date: The date to look up.\n            \n        Returns:\n            Word document if found, None otherwise.\n        \"\"\"\n        doc_ref = self._db.collection(self.COLLECTION_NAME).document(\n            target_date.isoformat()\n        )\n        doc = doc_ref.get()\n\n        if doc.exists:\n            return doc.to_dict()\n        return None\n",
                "filename": "firestore_client.py"
              },
              {
                "content": "\"\"\"HTTP function to get vocabulary words for the mobile app.\"\"\"\n\nimport json\nimport logging\nfrom datetime import date, timedelta\nfrom http import HTTPStatus\n\nimport functions_framework\nfrom flask import Request, Response\n\n# In Cloud Functions, all source files are bundled in the same directory\nfrom firestore_client import FirestoreClient\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nlogger = logging.getLogger(__name__)\n\n# CORS headers for Flutter app access\nCORS_HEADERS = {\n    \"Access-Control-Allow-Origin\": \"*\",\n    \"Access-Control-Allow-Methods\": \"GET, OPTIONS\",\n    \"Access-Control-Allow-Headers\": \"Content-Type\",\n    \"Access-Control-Max-Age\": \"3600\",\n}\n\n\ndef create_response(\n    data: dict,\n    status: int = HTTPStatus.OK\n) -\u003e Response:\n    \"\"\"Create a JSON response with CORS headers.\n    \n    Args:\n        data: Response data dictionary.\n        status: HTTP status code.\n        \n    Returns:\n        Flask Response object.\n    \"\"\"\n    response = Response(\n        json.dumps(data, ensure_ascii=False),\n        status=status,\n        mimetype=\"application/json\"\n    )\n    for key, value in CORS_HEADERS.items():\n        response.headers[key] = value\n    return response\n\n\n@functions_framework.http\ndef get_words(request: Request) -\u003e Response:\n    \"\"\"HTTP Cloud Function to get vocabulary words.\n    \n    Retrieves up to 30 days of words starting from today.\n    Returns available words even if some dates are missing.\n    \n    Args:\n        request: Flask request object.\n        \n    Returns:\n        JSON response with words list.\n    \"\"\"\n    # Handle CORS preflight request\n    if request.method == \"OPTIONS\":\n        return create_response({}, HTTPStatus.NO_CONTENT)\n\n    if request.method != \"GET\":\n        return create_response(\n            {\"error\": \"Method not allowed\"},\n            HTTPStatus.METHOD_NOT_ALLOWED\n        )\n\n    try:\n        # Get optional query parameters\n        days = request.args.get(\"days\", default=30, type=int)\n        days = min(max(days, 1), 30)  # Clamp between 1 and 30\n        \n        # Calculate date range\n        today = date.today()\n        end_date = today + timedelta(days=days - 1)\n        \n        # Fetch words from Firestore\n        client = FirestoreClient()\n        words = client.get_words_by_date_range(today, end_date)\n        \n        # Return available words (no error even if some dates are missing)\n        return create_response({\n            \"success\": True,\n            \"count\": len(words),\n            \"words\": words,\n            \"date_range\": {\n                \"start\": today.isoformat(),\n                \"end\": end_date.isoformat()\n            }\n        })\n        \n    except Exception as e:\n        logger.error(f\"Error fetching words: {e}\")\n        return create_response(\n            {\n                \"success\": False,\n                \"error\": \"Internal server error\",\n                \"words\": []\n            },\n            HTTPStatus.INTERNAL_SERVER_ERROR\n        )\n",
                "filename": "main.py"
              },
              {
                "content": "functions-framework==3.*\ngoogle-cloud-firestore\u003e=2.14.0\nflask\u003e=2.0.0\n",
                "filename": "requirements.txt"
              }
            ],
            "source_content": null,
            "source_content_filename": null,
            "source_dir": null,
            "source_file": null,
            "type": "zip"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0
        }
      ]
    },
    {
      "mode": "data",
      "type": "archive_file",
      "name": "score_answers_source",
      "provider": "provider[\"registry.terraform.io/hashicorp/archive\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "exclude_symlink_directories": null,
            "excludes": null,
            "id": "994bbf8ed7bf22307b9e204684f15dd241836ff5",
            "output_base64sha256": "fS65mFuUzX9+1by2atORnhU3aic1TdiOKRJv6oFSeQY=",
            "output_base64sha512": "0SCq4t2oHd1aJOgkHjrEIwtSvbeggN9o5qUmdr97MdDC9h0c7g27RT//d0X1ayTOsLxx56jrriQCRrnI5OV3Gw==",
            "output_file_mode": null,
            "output_md5": "ee7542186344a005f1a08f3955e1ccc7",
            "output_path": "./tmp/score_answers.zip",
            "output_sha": "994bbf8ed7bf22307b9e204684f15dd241836ff5",
            "output_sha256": "7d2eb9985b94cd7f7ed5bcb66ad3919e15376a27354dd88e29126fea81527906",
            "output_sha512": "d120aae2dda81ddd5a24e8241e3ac4230b52bdb7a080df68e6a52676bf7b31d0c2f61d1cee0dbb453fff7745f56b24ceb0bc71e7a8ebae240246b9c8e4e5771b",
            "output_size": 7213,
            "source": [
              {
                "content": "# Shared utilities for Cloud Functions\n",
                "filename": "__init__.py"
              },
              {
                "content": "\"\"\"Cloud Function to score user answers using Gemini AI.\"\"\"\n\nimport json\nimport logging\nimport os\nimport time\nimport traceback\nfrom collections import defaultdict\nfrom http import HTTPStatus\nfrom threading import Lock\n\nimport functions_framework\nfrom flask import Request, Response\n\nfrom gemini_client import GeminiClient, GeminiClientError\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nPROJECT_ID = os.environ.get(\"GCP_PROJECT\")\n\n# Rate limiting configuration\nRATE_LIMIT_WINDOW_SECONDS = 60  # 1 minute window\nRATE_LIMIT_MAX_REQUESTS = 10  # Max 10 requests per window\n\n# In-memory rate limiting storage\n# Note: This is per-instance and not shared across Cloud Functions instances\n_rate_limit_store: dict[str, list[float]] = defaultdict(list)\n_rate_limit_lock = Lock()\n\n\ndef _get_client_ip(request: Request) -\u003e str:\n    \"\"\"Extract client IP from request, considering proxies.\"\"\"\n    # X-Forwarded-For may contain multiple IPs; take the first one\n    forwarded_for = request.headers.get(\"X-Forwarded-For\", \"\")\n    if forwarded_for:\n        return forwarded_for.split(\",\")[0].strip()\n    return request.remote_addr or \"unknown\"\n\n\ndef _cleanup_old_requests(timestamps: list[float], window_start: float) -\u003e list[float]:\n    \"\"\"Remove timestamps older than the rate limit window.\"\"\"\n    return [ts for ts in timestamps if ts \u003e window_start]\n\n\ndef _check_rate_limit(client_ip: str) -\u003e tuple[bool, int]:\n    \"\"\"Check if the client IP has exceeded the rate limit.\n    \n    Returns:\n        tuple: (is_allowed, retry_after_seconds)\n            - is_allowed: True if request is allowed, False if rate limited\n            - retry_after_seconds: Seconds until rate limit resets (0 if allowed)\n    \"\"\"\n    current_time = time.time()\n    window_start = current_time - RATE_LIMIT_WINDOW_SECONDS\n    \n    with _rate_limit_lock:\n        # Cleanup old requests\n        _rate_limit_store[client_ip] = _cleanup_old_requests(\n            _rate_limit_store[client_ip], window_start\n        )\n        \n        request_count = len(_rate_limit_store[client_ip])\n        \n        if request_count \u003e= RATE_LIMIT_MAX_REQUESTS:\n            # Calculate when the oldest request in the window will expire\n            oldest_in_window = min(_rate_limit_store[client_ip])\n            retry_after = int(oldest_in_window + RATE_LIMIT_WINDOW_SECONDS - current_time) + 1\n            return False, max(1, retry_after)\n        \n        # Record this request\n        _rate_limit_store[client_ip].append(current_time)\n        return True, 0\n\n\n@functions_framework.http\ndef score_answers(request: Request) -\u003e Response:\n    \"\"\"HTTP Cloud Function to score user answers.\n    \n    Args:\n        request: Flask request object with JSON body:\n            - word: The target word (お題)\n            - answers: List of user's answers\n            - game_type: \"word_replacement\" or \"rhyming\"\n        \n    Returns:\n        JSON response with score and feedback.\n    \"\"\"\n    # Handle CORS preflight\n    if request.method == \"OPTIONS\":\n        headers = {\n            \"Access-Control-Allow-Origin\": \"*\",\n            \"Access-Control-Allow-Methods\": \"POST, OPTIONS\",\n            \"Access-Control-Allow-Headers\": \"Content-Type\",\n            \"Access-Control-Max-Age\": \"3600\",\n        }\n        return Response(\"\", status=HTTPStatus.NO_CONTENT, headers=headers)\n\n    headers = {\"Access-Control-Allow-Origin\": \"*\"}\n\n    # Rate limiting check\n    client_ip = _get_client_ip(request)\n    is_allowed, retry_after = _check_rate_limit(client_ip)\n    \n    if not is_allowed:\n        logger.warning(f\"Rate limit exceeded for IP: {client_ip}\")\n        rate_limit_headers = {\n            **headers,\n            \"Retry-After\": str(retry_after),\n        }\n        return Response(\n            json.dumps(\n                {\n                    \"success\": False,\n                    \"error\": \"リクエスト制限を超えました。しばらくしてから再度お試しください。\",\n                },\n                ensure_ascii=False,\n            ),\n            status=HTTPStatus.TOO_MANY_REQUESTS,\n            mimetype=\"application/json\",\n            headers=rate_limit_headers,\n        )\n\n    try:\n        request_json = request.get_json(silent=True)\n        \n        if not request_json:\n            return Response(\n                '{\"success\": false, \"error\": \"Request body is required\"}',\n                status=HTTPStatus.BAD_REQUEST,\n                mimetype=\"application/json\",\n                headers=headers,\n            )\n\n        word = request_json.get(\"word\")\n        answers = request_json.get(\"answers\", [])\n        game_type = request_json.get(\"game_type\")\n        locale = request_json.get(\"locale\", \"ja\")  # Default to Japanese\n\n        if not word:\n            return Response(\n                '{\"success\": false, \"error\": \"word is required\"}',\n                status=HTTPStatus.BAD_REQUEST,\n                mimetype=\"application/json\",\n                headers=headers,\n            )\n\n        if not game_type or game_type not in [\"word_replacement\", \"rhyming\"]:\n            return Response(\n                '{\"success\": false, \"error\": \"game_type must be word_replacement or rhyming\"}',\n                status=HTTPStatus.BAD_REQUEST,\n                mimetype=\"application/json\",\n                headers=headers,\n            )\n\n        # Input size validation\n        MAX_ANSWERS_COUNT = 50\n        MAX_WORD_LENGTH = 200\n        MAX_ANSWER_LENGTH = 500\n\n        if len(answers) \u003e MAX_ANSWERS_COUNT:\n            return Response(\n                json.dumps(\n                    {\"success\": False, \"error\": f\"answers配列は最大{MAX_ANSWERS_COUNT}件までです\"},\n                    ensure_ascii=False,\n                ),\n                status=HTTPStatus.BAD_REQUEST,\n                mimetype=\"application/json\",\n                headers=headers,\n            )\n\n        if len(word) \u003e MAX_WORD_LENGTH:\n            return Response(\n                json.dumps(\n                    {\"success\": False, \"error\": f\"wordは最大{MAX_WORD_LENGTH}文字までです\"},\n                    ensure_ascii=False,\n                ),\n                status=HTTPStatus.BAD_REQUEST,\n                mimetype=\"application/json\",\n                headers=headers,\n            )\n\n        for i, answer in enumerate(answers):\n            if not isinstance(answer, str):\n                return Response(\n                    json.dumps(\n                        {\"success\": False, \"error\": f\"answers[{i}]は文字列である必要があります\"},\n                        ensure_ascii=False,\n                    ),\n                    status=HTTPStatus.BAD_REQUEST,\n                    mimetype=\"application/json\",\n                    headers=headers,\n                )\n            if len(answer) \u003e MAX_ANSWER_LENGTH:\n                return Response(\n                    json.dumps(\n                        {\"success\": False, \"error\": f\"answers[{i}]は最大{MAX_ANSWER_LENGTH}文字までです\"},\n                        ensure_ascii=False,\n                    ),\n                    status=HTTPStatus.BAD_REQUEST,\n                    mimetype=\"application/json\",\n                    headers=headers,\n                )\n\n        logger.info(f\"Scoring answers for word: {word}, game_type: {game_type}, answers: {answers}\")\n\n        gemini_client = GeminiClient(project_id=PROJECT_ID)\n        result = gemini_client.score_answers(\n            word=word,\n            answers=answers,\n            game_type=game_type,\n            locale=locale,\n        )\n\n        response_data = {\n            \"success\": True,\n            \"score\": result.get(\"score\", 0),\n            \"feedback\": result.get(\"feedback\", \"\"),\n        }\n\n        return Response(\n            json.dumps(response_data, ensure_ascii=False),\n            status=HTTPStatus.OK,\n            mimetype=\"application/json\",\n            headers=headers,\n        )\n\n    except GeminiClientError as e:\n        logger.error(f\"Gemini API error: {e}\")\n        logger.error(traceback.format_exc())\n        return Response(\n            json.dumps({\"success\": False, \"error\": f\"AI scoring failed: {str(e)}\"}, ensure_ascii=False),\n            status=HTTPStatus.INTERNAL_SERVER_ERROR,\n            mimetype=\"application/json\",\n            headers=headers,\n        )\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\")\n        logger.error(traceback.format_exc())\n        return Response(\n            json.dumps({\"success\": False, \"error\": f\"Internal server error: {str(e)}\"}, ensure_ascii=False),\n            status=HTTPStatus.INTERNAL_SERVER_ERROR,\n            mimetype=\"application/json\",\n            headers=headers,\n        )\n",
                "filename": "main.py"
              },
              {
                "content": "\"\"\"Gemini client for vocabulary word generation using Vertex AI.\"\"\"\n\nimport json\nimport logging\nfrom typing import Optional\n\nimport vertexai\nfrom vertexai.generative_models import GenerativeModel, GenerationConfig\n\nlogger = logging.getLogger(__name__)\n\n\nclass GeminiClientError(Exception):\n    \"\"\"Base exception for Gemini client errors.\"\"\"\n    pass\n\n\nclass GeminiParseError(GeminiClientError):\n    \"\"\"Raised when response cannot be parsed as expected JSON.\"\"\"\n    pass\n\n\nclass GeminiClient:\n    \"\"\"Client for generating vocabulary words using Gemini 2.5 Flash.\"\"\"\n\n    MODEL_NAME = \"gemini-2.5-flash\"\n    \n    SYSTEM_PROMPT = \"\"\"あなたは日本語の語彙力トレーニングアプリのための単語生成AIです。\n\nあなたの役割は、指定された日付に対して抽象的で少し難しい日本語の名詞を生成し、その英訳も提供することです。\n\n## 出力ルール\n- 必ず以下のJSON形式のみで出力してください。説明文や追加のテキストは一切含めないでください。\n- 各単語は「word」(漢字表記)、「reading」(ひらがな読み)、「word_en」(英語訳)を含めてください。\n\n## JSON形式\n{\n  \"words\": [\n    {\n      \"date\": \"YYYY-MM-DD\",\n      \"word\": \"単語\",\n      \"reading\": \"たんご\",\n      \"word_en\": \"English translation\"\n    }\n  ]\n}\n\n## 単語選定基準\n- 抽象的な概念を表す名詞を選ぶこと\n- 日常会話ではあまり使われないが、知っていると語彙力が高いと感じられる単語\n- 小学校高学年〜中学生レベルの漢字で構成される単語\n- 例: 概念(concept)、帰結(consequence)、矛盾(contradiction)、逆説(paradox)、恩恵(blessing)\"\"\"\n\n    def __init__(\n        self,\n        project_id: Optional[str] = None,\n        location: str = \"asia-northeast1\"\n    ):\n        \"\"\"Initialize Gemini client.\n        \n        Args:\n            project_id: GCP project ID.\n            location: Vertex AI location.\n        \"\"\"\n        vertexai.init(project=project_id, location=location)\n        self._model = GenerativeModel(\n            self.MODEL_NAME,\n            system_instruction=self.SYSTEM_PROMPT\n        )\n        self._generation_config = GenerationConfig(\n            temperature=0.8,\n            max_output_tokens=8192,\n            response_mime_type=\"application/json\"\n        )\n\n    def generate_words(\n        self,\n        dates: list[str],\n        recent_words: list[str]\n    ) -\u003e list[dict]:\n        \"\"\"Generate vocabulary words for specified dates.\n        \n        Args:\n            dates: List of date strings (YYYY-MM-DD) to generate words for.\n            recent_words: List of recent words to avoid duplication.\n            \n        Returns:\n            List of generated word dictionaries.\n            \n        Raises:\n            GeminiParseError: If response cannot be parsed.\n            GeminiClientError: For other API errors.\n        \"\"\"\n        if not dates:\n            return []\n\n        # Build prompt with context\n        recent_words_str = \"、\".join(recent_words) if recent_words else \"なし\"\n        dates_str = \", \".join(dates)\n        \n        prompt = f\"\"\"以下の日付に対して、それぞれ1つずつ抽象的で少し難しい日本語の名詞を生成してください。\n\n対象日付: {dates_str}\n\n## 重複回避\n以下の直近の単語とは重複しない単語を選んでください:\n{recent_words_str}\n\n上記の形式で、{len(dates)}件の単語をJSON形式で出力してください。\"\"\"\n\n        try:\n            response = self._model.generate_content(\n                prompt,\n                generation_config=self._generation_config\n            )\n            \n            return self._parse_response(response.text)\n            \n        except json.JSONDecodeError as e:\n            logger.error(f\"Failed to parse Gemini response: {e}\")\n            raise GeminiParseError(f\"Invalid JSON response: {e}\") from e\n        except Exception as e:\n            logger.error(f\"Gemini API error: {e}\")\n            raise GeminiClientError(f\"API error: {e}\") from e\n\n    def _parse_response(self, response_text: str) -\u003e list[dict]:\n        \"\"\"Parse and validate the JSON response.\n        \n        Args:\n            response_text: Raw response text from Gemini.\n            \n        Returns:\n            List of validated word dictionaries.\n            \n        Raises:\n            GeminiParseError: If parsing or validation fails.\n        \"\"\"\n        try:\n            # Clean response text (remove markdown code blocks if present)\n            cleaned = response_text.strip()\n            if cleaned.startswith(\"```json\"):\n                cleaned = cleaned[7:]\n            if cleaned.startswith(\"```\"):\n                cleaned = cleaned[3:]\n            if cleaned.endswith(\"```\"):\n                cleaned = cleaned[:-3]\n            cleaned = cleaned.strip()\n\n            data = json.loads(cleaned)\n            \n            if \"words\" not in data:\n                raise GeminiParseError(\"Response missing 'words' key\")\n            \n            words = data[\"words\"]\n            validated_words = []\n            \n            for word in words:\n                if not all(k in word for k in [\"date\", \"word\", \"reading\", \"word_en\"]):\n                    logger.warning(f\"Skipping invalid word entry: {word}\")\n                    continue\n                validated_words.append({\n                    \"date\": word[\"date\"],\n                    \"word\": word[\"word\"],\n                    \"reading\": word[\"reading\"],\n                    \"word_en\": word[\"word_en\"]\n                })\n            \n            return validated_words\n            \n            return validated_words\n            \n        except json.JSONDecodeError as e:\n            raise GeminiParseError(f\"Failed to parse JSON: {e}\") from e\n\n    def score_answers(\n        self,\n        word: str,\n        answers: list[str],\n        game_type: str,\n        locale: str = \"ja\",\n    ) -\u003e dict:\n        \"\"\"Score user answers for vocabulary game.\n        \n        Args:\n            word: The target word (お題).\n            answers: List of user's answers.\n            game_type: \"word_replacement\" or \"rhyming\".\n            locale: Language for prompts (\"ja\" or \"en\").\n            \n        Returns:\n            Dictionary with score (0-100) and feedback.\n            \n        Raises:\n            GeminiClientError: For API errors.\n        \"\"\"\n        is_english = locale == \"en\"\n        game_context = self._get_game_context(game_type, is_english)\n        \n        if is_english:\n            system_prompt = f\"\"\"You are a linguistics expert. Score the user's word list against the given topic using the following criteria, and return your response in JSON format.\n\nEvaluation Criteria:\n{game_context}\n\nResponse Format (must return in this exact JSON format):\n{{\n  \"score\": \u003cinteger from 0-100\u003e,\n  \"feedback\": \"\u003cfeedback in English including scoring reasons and suggestions for improvement\u003e\"\n}}\n\nScoring Guidelines:\n- Each word is worth up to 10 points\n- Score up to 10 words maximum (100 points total)\n- Duplicate words are not scored\n- Inappropriate or irrelevant words score 0\n- Evaluate creativity and vocabulary richness\"\"\"\n        else:\n            system_prompt = f\"\"\"あなたは言語学の専門家です。提示された『お題』に対して、ユーザーが入力した『単語リスト』を以下の基準で採点し、JSON形式で返してください。\n\n評価基準：\n{game_context}\n\n回答形式（必ずこの形式のJSONで返してください）：\n{{\n  \"score\": \u003c0-100の整数\u003e,\n  \"feedback\": \"\u003c採点理由と改善点を含む日本語のフィードバック\u003e\"\n}}\n\n採点のポイント：\n- 各単語は最大10点\n- 最大10単語まで採点（100点満点）\n- 重複した単語は採点しない\n- 不適切または無関係な単語は0点\n- 創造性と語彙力の豊かさを評価\"\"\"\n\n        if is_english:\n            game_type_name = \"Word Replacement\" if game_type == \"word_replacement\" else \"Rhyming\"\n            answers_text = \"\\n\".join(f\"• {a}\" for a in answers) if answers else \"(No answers)\"\n            user_prompt = f\"\"\"【Game Type】{game_type_name}\n\n【Topic】{word}\n\n【User's Answers】\n{answers_text}\n\nPlease score the above answers.\"\"\"\n        else:\n            game_type_name = \"言葉の置き換え\" if game_type == \"word_replacement\" else \"韻を踏む\"\n            answers_text = \"\\n\".join(f\"・{a}\" for a in answers) if answers else \"（回答なし）\"\n            user_prompt = f\"\"\"【ゲーム種別】{game_type_name}\n\n【お題】{word}\n\n【ユーザーの回答】\n{answers_text}\n\n上記の回答を採点してください。\"\"\"\n\n        try:\n            model = GenerativeModel(\n                self.MODEL_NAME,\n                system_instruction=system_prompt,\n            )\n            \n            config = GenerationConfig(\n                temperature=0.7,\n                max_output_tokens=8192,\n                response_mime_type=\"application/json\",\n            )\n            \n            response = model.generate_content(user_prompt, generation_config=config)\n            return self._parse_score_response(response.text)\n            \n        except Exception as e:\n            logger.error(f\"Gemini API error during scoring: {e}\")\n            raise GeminiClientError(f\"Scoring API error: {e}\") from e\n\n    def _get_game_context(self, game_type: str, is_english: bool = False) -\u003e str:\n        \"\"\"Get evaluation context for the game type.\"\"\"\n        if game_type == \"word_replacement\":\n            if is_english:\n                return \"\"\"【Word Replacement Game】\n- Evaluate words with the same or similar meaning to the topic word\n- Priority on appropriateness as synonyms\n- Higher scores for more refined expressions or specialized alternatives\"\"\"\n            else:\n                return \"\"\"【言葉の置き換えゲーム】\n- お題の単語と同じ意味、または類似の意味を持つ単語を評価\n- 同義語、類義語としての適切さを重視\n- より洗練された表現や専門的な言い換えは高得点\"\"\"\n        else:\n            if is_english:\n                return \"\"\"【Rhyming Game】\n- Evaluate whether words rhyme with the topic (matching end sounds)\n- Evaluate not just sound matching but also cleverness of the word\n- Higher scores for creative and unexpected rhymes\"\"\"\n            else:\n                return \"\"\"【韻を踏むゲーム】\n- お題の単語と韻を踏んでいるか（語尾の音が一致しているか）を評価\n- 単なる音の一致だけでなく、言葉としての面白さも評価\n- 創造的で意外性のある韻は高得点\"\"\"\n\n    def _parse_score_response(self, response_text: str) -\u003e dict:\n        \"\"\"Parse the scoring response.\"\"\"\n        try:\n            cleaned = response_text.strip()\n            if cleaned.startswith(\"```json\"):\n                cleaned = cleaned[7:]\n            if cleaned.startswith(\"```\"):\n                cleaned = cleaned[3:]\n            if cleaned.endswith(\"```\"):\n                cleaned = cleaned[:-3]\n            cleaned = cleaned.strip()\n            \n            data = json.loads(cleaned)\n            \n            return {\n                \"score\": int(data.get(\"score\", 0)),\n                \"feedback\": str(data.get(\"feedback\", \"\")),\n            }\n            \n        except (json.JSONDecodeError, ValueError) as e:\n            logger.error(f\"Failed to parse score response: {e}\")\n            return {\n                \"score\": 0,\n                \"feedback\": \"スコアの解析に失敗しました。\",\n            }\n\n",
                "filename": "gemini_client.py"
              },
              {
                "content": "functions-framework==3.*\ngoogle-cloud-aiplatform\u003e=1.38.0\nflask\u003e=2.0.0\n",
                "filename": "requirements.txt"
              }
            ],
            "source_content": null,
            "source_content_filename": null,
            "source_dir": null,
            "source_file": null,
            "type": "zip"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_cloud_run_service_iam_member",
      "name": "generate_words_invoker",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "condition": [],
            "etag": "BwZHOHqiVHE=",
            "id": "v1/projects/goiryoku-kojo/locations/asia-northeast1/services/generate-words/roles/run.invoker/serviceAccount:goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
            "location": "asia-northeast1",
            "member": "serviceAccount:goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
            "project": "goiryoku-kojo",
            "role": "roles/run.invoker",
            "service": "v1/projects/goiryoku-kojo/locations/asia-northeast1/services/generate-words"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "bnVsbA==",
          "dependencies": [
            "data.archive_file.generate_words_source",
            "google_cloudfunctions2_function.generate_words",
            "google_project_service.aiplatform",
            "google_project_service.cloudbuild",
            "google_project_service.cloudfunctions",
            "google_project_service.run",
            "google_service_account.functions_sa",
            "google_storage_bucket.functions_bucket",
            "google_storage_bucket_object.generate_words_source"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_cloud_run_service_iam_member",
      "name": "get_words_invoker",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "condition": [],
            "etag": "BwZHN6fqG0w=",
            "id": "v1/projects/goiryoku-kojo/locations/asia-northeast1/services/get-words/roles/run.invoker/allUsers",
            "location": "asia-northeast1",
            "member": "allUsers",
            "project": "goiryoku-kojo",
            "role": "roles/run.invoker",
            "service": "v1/projects/goiryoku-kojo/locations/asia-northeast1/services/get-words"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "bnVsbA==",
          "dependencies": [
            "data.archive_file.get_words_source",
            "google_cloudfunctions2_function.get_words",
            "google_project_service.cloudbuild",
            "google_project_service.cloudfunctions",
            "google_project_service.run",
            "google_service_account.functions_sa",
            "google_storage_bucket.functions_bucket",
            "google_storage_bucket_object.get_words_source"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_cloud_run_service_iam_member",
      "name": "score_answers_invoker",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "condition": [],
            "etag": "BwZHTDlrWFA=",
            "id": "v1/projects/goiryoku-kojo/locations/asia-northeast1/services/score-answers/roles/run.invoker/allUsers",
            "location": "asia-northeast1",
            "member": "allUsers",
            "project": "goiryoku-kojo",
            "role": "roles/run.invoker",
            "service": "v1/projects/goiryoku-kojo/locations/asia-northeast1/services/score-answers"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "bnVsbA==",
          "dependencies": [
            "data.archive_file.score_answers_source",
            "google_cloudfunctions2_function.score_answers",
            "google_project_service.aiplatform",
            "google_project_service.cloudbuild",
            "google_project_service.cloudfunctions",
            "google_project_service.run",
            "google_service_account.functions_sa",
            "google_storage_bucket.functions_bucket",
            "google_storage_bucket_object.score_answers_source"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_cloud_scheduler_job",
      "name": "generate_words_daily",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "app_engine_http_target": [],
            "attempt_deadline": "320s",
            "description": "Trigger word generation daily at 0:00 JST",
            "http_target": [
              {
                "body": "",
                "headers": {},
                "http_method": "POST",
                "oauth_token": [],
                "oidc_token": [
                  {
                    "audience": "https://generate-words-cqiy6alq3a-an.a.run.app/",
                    "service_account_email": "goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com"
                  }
                ],
                "uri": "https://generate-words-cqiy6alq3a-an.a.run.app/"
              }
            ],
            "id": "projects/goiryoku-kojo/locations/asia-northeast1/jobs/goiryoku-generate-words-daily",
            "name": "goiryoku-generate-words-daily",
            "paused": false,
            "project": "goiryoku-kojo",
            "pubsub_target": [],
            "region": "asia-northeast1",
            "retry_config": [],
            "schedule": "0 0 * * *",
            "state": "ENABLED",
            "time_zone": "Asia/Tokyo",
            "timeouts": null
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoxMjAwMDAwMDAwMDAwLCJkZWxldGUiOjEyMDAwMDAwMDAwMDAsInVwZGF0ZSI6MTIwMDAwMDAwMDAwMH19",
          "dependencies": [
            "data.archive_file.generate_words_source",
            "google_cloudfunctions2_function.generate_words",
            "google_project_service.aiplatform",
            "google_project_service.cloudbuild",
            "google_project_service.cloudfunctions",
            "google_project_service.cloudscheduler",
            "google_project_service.run",
            "google_service_account.functions_sa",
            "google_storage_bucket.functions_bucket",
            "google_storage_bucket_object.generate_words_source"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_cloudfunctions2_function",
      "name": "generate_words",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "build_config": [
              {
                "automatic_update_policy": [
                  {}
                ],
                "build": "projects/561096623466/locations/asia-northeast1/builds/ec88d31c-d3db-4b82-81af-aa962c576de0",
                "docker_repository": "projects/goiryoku-kojo/locations/asia-northeast1/repositories/gcf-artifacts",
                "entry_point": "generate_words",
                "environment_variables": {},
                "on_deploy_update_policy": [],
                "runtime": "python311",
                "service_account": "projects/goiryoku-kojo/serviceAccounts/561096623466-compute@developer.gserviceaccount.com",
                "source": [
                  {
                    "repo_source": [],
                    "storage_source": [
                      {
                        "bucket": "goiryoku-kojo-goiryoku-functions",
                        "generation": 1767154119815896,
                        "object": "generate_words-11780625523fd42e15118f3d28dc5457.zip"
                      }
                    ]
                  }
                ],
                "worker_pool": ""
              }
            ],
            "description": "",
            "effective_labels": {},
            "environment": "GEN_2",
            "event_trigger": [],
            "id": "projects/goiryoku-kojo/locations/asia-northeast1/functions/generate-words",
            "kms_key_name": "",
            "labels": {},
            "location": "asia-northeast1",
            "name": "generate-words",
            "project": "goiryoku-kojo",
            "service_config": [
              {
                "all_traffic_on_latest_revision": true,
                "available_cpu": "0.3333",
                "available_memory": "512M",
                "environment_variables": {
                  "GCP_PROJECT": "goiryoku-kojo",
                  "LOG_EXECUTION_ID": "true"
                },
                "gcf_uri": "",
                "ingress_settings": "ALLOW_ALL",
                "max_instance_count": 1,
                "max_instance_request_concurrency": 1,
                "min_instance_count": 0,
                "secret_environment_variables": [],
                "secret_volumes": [],
                "service": "projects/goiryoku-kojo/locations/asia-northeast1/services/generate-words",
                "service_account_email": "goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
                "timeout_seconds": 300,
                "uri": "https://generate-words-cqiy6alq3a-an.a.run.app",
                "vpc_connector": "",
                "vpc_connector_egress_settings": ""
              }
            ],
            "state": "ACTIVE",
            "terraform_labels": {},
            "timeouts": null,
            "update_time": "2026-01-01T17:01:03.138298331Z",
            "url": "https://asia-northeast1-goiryoku-kojo.cloudfunctions.net/generate-words"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjozNjAwMDAwMDAwMDAwLCJkZWxldGUiOjM2MDAwMDAwMDAwMDAsInVwZGF0ZSI6MzYwMDAwMDAwMDAwMH19",
          "dependencies": [
            "data.archive_file.generate_words_source",
            "google_project_service.aiplatform",
            "google_project_service.cloudbuild",
            "google_project_service.cloudfunctions",
            "google_project_service.run",
            "google_service_account.functions_sa",
            "google_storage_bucket.functions_bucket",
            "google_storage_bucket_object.generate_words_source"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_cloudfunctions2_function",
      "name": "get_words",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "build_config": [
              {
                "automatic_update_policy": [
                  {}
                ],
                "build": "projects/561096623466/locations/asia-northeast1/builds/ee0840d7-f7a9-45ab-b4e1-2e9ef611ed26",
                "docker_repository": "projects/goiryoku-kojo/locations/asia-northeast1/repositories/gcf-artifacts",
                "entry_point": "get_words",
                "environment_variables": {},
                "on_deploy_update_policy": [],
                "runtime": "python311",
                "service_account": "projects/goiryoku-kojo/serviceAccounts/561096623466-compute@developer.gserviceaccount.com",
                "source": [
                  {
                    "repo_source": [],
                    "storage_source": [
                      {
                        "bucket": "goiryoku-kojo-goiryoku-functions",
                        "generation": 1767154119816095,
                        "object": "get_words-b17ce43f85e4ee00e230a72e46fbc68f.zip"
                      }
                    ]
                  }
                ],
                "worker_pool": ""
              }
            ],
            "description": "",
            "effective_labels": {},
            "environment": "GEN_2",
            "event_trigger": [],
            "id": "projects/goiryoku-kojo/locations/asia-northeast1/functions/get-words",
            "kms_key_name": "",
            "labels": {},
            "location": "asia-northeast1",
            "name": "get-words",
            "project": "goiryoku-kojo",
            "service_config": [
              {
                "all_traffic_on_latest_revision": true,
                "available_cpu": "0.1666",
                "available_memory": "256M",
                "environment_variables": {
                  "GCP_PROJECT": "goiryoku-kojo",
                  "LOG_EXECUTION_ID": "true"
                },
                "gcf_uri": "",
                "ingress_settings": "ALLOW_ALL",
                "max_instance_count": 10,
                "max_instance_request_concurrency": 1,
                "min_instance_count": 0,
                "secret_environment_variables": [],
                "secret_volumes": [],
                "service": "projects/goiryoku-kojo/locations/asia-northeast1/services/get-words",
                "service_account_email": "goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
                "timeout_seconds": 60,
                "uri": "https://get-words-cqiy6alq3a-an.a.run.app",
                "vpc_connector": "",
                "vpc_connector_egress_settings": ""
              }
            ],
            "state": "ACTIVE",
            "terraform_labels": {},
            "timeouts": null,
            "update_time": "2026-01-01T17:00:52.178982688Z",
            "url": "https://asia-northeast1-goiryoku-kojo.cloudfunctions.net/get-words"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjozNjAwMDAwMDAwMDAwLCJkZWxldGUiOjM2MDAwMDAwMDAwMDAsInVwZGF0ZSI6MzYwMDAwMDAwMDAwMH19",
          "dependencies": [
            "data.archive_file.get_words_source",
            "google_project_service.cloudbuild",
            "google_project_service.cloudfunctions",
            "google_project_service.run",
            "google_service_account.functions_sa",
            "google_storage_bucket.functions_bucket",
            "google_storage_bucket_object.get_words_source"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_cloudfunctions2_function",
      "name": "score_answers",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "build_config": [
              {
                "automatic_update_policy": [
                  {}
                ],
                "build": "projects/561096623466/locations/asia-northeast1/builds/fccf60f3-9f32-4f4b-a18d-eab7d7197ad4",
                "docker_repository": "projects/goiryoku-kojo/locations/asia-northeast1/repositories/gcf-artifacts",
                "entry_point": "score_answers",
                "environment_variables": {},
                "on_deploy_update_policy": [],
                "runtime": "python311",
                "service_account": "projects/goiryoku-kojo/serviceAccounts/561096623466-compute@developer.gserviceaccount.com",
                "source": [
                  {
                    "repo_source": [],
                    "storage_source": [
                      {
                        "bucket": "goiryoku-kojo-goiryoku-functions",
                        "generation": 1767242471349846,
                        "object": "score_answers-ee7542186344a005f1a08f3955e1ccc7.zip"
                      }
                    ]
                  }
                ],
                "worker_pool": ""
              }
            ],
            "description": "",
            "effective_labels": {},
            "environment": "GEN_2",
            "event_trigger": [],
            "id": "projects/goiryoku-kojo/locations/asia-northeast1/functions/score-answers",
            "kms_key_name": "",
            "labels": {},
            "location": "asia-northeast1",
            "name": "score-answers",
            "project": "goiryoku-kojo",
            "service_config": [
              {
                "all_traffic_on_latest_revision": true,
                "available_cpu": "0.3333",
                "available_memory": "512M",
                "environment_variables": {
                  "GCP_PROJECT": "goiryoku-kojo",
                  "LOG_EXECUTION_ID": "true"
                },
                "gcf_uri": "",
                "ingress_settings": "ALLOW_ALL",
                "max_instance_count": 10,
                "max_instance_request_concurrency": 1,
                "min_instance_count": 0,
                "secret_environment_variables": [],
                "secret_volumes": [],
                "service": "projects/goiryoku-kojo/locations/asia-northeast1/services/score-answers",
                "service_account_email": "goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
                "timeout_seconds": 60,
                "uri": "https://score-answers-cqiy6alq3a-an.a.run.app",
                "vpc_connector": "",
                "vpc_connector_egress_settings": ""
              }
            ],
            "state": "ACTIVE",
            "terraform_labels": {},
            "timeouts": null,
            "update_time": "2026-01-01T17:01:03.206857277Z",
            "url": "https://asia-northeast1-goiryoku-kojo.cloudfunctions.net/score-answers"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjozNjAwMDAwMDAwMDAwLCJkZWxldGUiOjM2MDAwMDAwMDAwMDAsInVwZGF0ZSI6MzYwMDAwMDAwMDAwMH19",
          "dependencies": [
            "data.archive_file.score_answers_source",
            "google_project_service.aiplatform",
            "google_project_service.cloudbuild",
            "google_project_service.cloudfunctions",
            "google_project_service.run",
            "google_service_account.functions_sa",
            "google_storage_bucket.functions_bucket",
            "google_storage_bucket_object.score_answers_source"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_firestore_database",
      "name": "database",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "app_engine_integration_mode": "DISABLED",
            "cmek_config": [],
            "concurrency_mode": "PESSIMISTIC",
            "create_time": "",
            "delete_protection_state": "DELETE_PROTECTION_DISABLED",
            "deletion_policy": "ABANDON",
            "earliest_version_time": "2026-01-01T15:59:54.764969Z",
            "etag": "IMX/+Kzo6pEDMLm3sLPY55ED",
            "id": "projects/goiryoku-kojo/databases/(default)",
            "key_prefix": "",
            "location_id": "asia-northeast1",
            "name": "(default)",
            "point_in_time_recovery_enablement": "POINT_IN_TIME_RECOVERY_DISABLED",
            "project": "goiryoku-kojo",
            "timeouts": null,
            "type": "FIRESTORE_NATIVE",
            "uid": "e626342e-6f9e-4d38-91a1-37aa8d819188",
            "update_time": "",
            "version_retention_period": "3600s"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoxMjAwMDAwMDAwMDAwLCJkZWxldGUiOjEyMDAwMDAwMDAwMDAsInVwZGF0ZSI6MTIwMDAwMDAwMDAwMH19",
          "dependencies": [
            "google_project_service.firestore"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_project_iam_member",
      "name": "functions_aiplatform",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "condition": [],
            "etag": "BwZHUcNjyz4=",
            "id": "goiryoku-kojo/roles/aiplatform.user/serviceAccount:goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
            "member": "serviceAccount:goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
            "project": "goiryoku-kojo",
            "role": "roles/aiplatform.user"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "bnVsbA==",
          "dependencies": [
            "google_service_account.functions_sa"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_project_iam_member",
      "name": "functions_datastore",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "condition": [],
            "etag": "BwZHUcNjyz4=",
            "id": "goiryoku-kojo/roles/datastore.user/serviceAccount:goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
            "member": "serviceAccount:goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
            "project": "goiryoku-kojo",
            "role": "roles/datastore.user"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "bnVsbA==",
          "dependencies": [
            "google_service_account.functions_sa"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_project_service",
      "name": "aiplatform",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "disable_dependent_services": null,
            "disable_on_destroy": false,
            "id": "goiryoku-kojo/aiplatform.googleapis.com",
            "project": "goiryoku-kojo",
            "service": "aiplatform.googleapis.com",
            "timeouts": null
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoxMjAwMDAwMDAwMDAwLCJkZWxldGUiOjEyMDAwMDAwMDAwMDAsInJlYWQiOjYwMDAwMDAwMDAwMCwidXBkYXRlIjoxMjAwMDAwMDAwMDAwfX0="
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_project_service",
      "name": "cloudbuild",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "disable_dependent_services": null,
            "disable_on_destroy": false,
            "id": "goiryoku-kojo/cloudbuild.googleapis.com",
            "project": "goiryoku-kojo",
            "service": "cloudbuild.googleapis.com",
            "timeouts": null
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoxMjAwMDAwMDAwMDAwLCJkZWxldGUiOjEyMDAwMDAwMDAwMDAsInJlYWQiOjYwMDAwMDAwMDAwMCwidXBkYXRlIjoxMjAwMDAwMDAwMDAwfX0="
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_project_service",
      "name": "cloudfunctions",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "disable_dependent_services": null,
            "disable_on_destroy": false,
            "id": "goiryoku-kojo/cloudfunctions.googleapis.com",
            "project": "goiryoku-kojo",
            "service": "cloudfunctions.googleapis.com",
            "timeouts": null
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoxMjAwMDAwMDAwMDAwLCJkZWxldGUiOjEyMDAwMDAwMDAwMDAsInJlYWQiOjYwMDAwMDAwMDAwMCwidXBkYXRlIjoxMjAwMDAwMDAwMDAwfX0="
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_project_service",
      "name": "cloudscheduler",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "disable_dependent_services": null,
            "disable_on_destroy": false,
            "id": "goiryoku-kojo/cloudscheduler.googleapis.com",
            "project": "goiryoku-kojo",
            "service": "cloudscheduler.googleapis.com",
            "timeouts": null
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoxMjAwMDAwMDAwMDAwLCJkZWxldGUiOjEyMDAwMDAwMDAwMDAsInJlYWQiOjYwMDAwMDAwMDAwMCwidXBkYXRlIjoxMjAwMDAwMDAwMDAwfX0="
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_project_service",
      "name": "firestore",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "disable_dependent_services": null,
            "disable_on_destroy": false,
            "id": "goiryoku-kojo/firestore.googleapis.com",
            "project": "goiryoku-kojo",
            "service": "firestore.googleapis.com",
            "timeouts": null
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoxMjAwMDAwMDAwMDAwLCJkZWxldGUiOjEyMDAwMDAwMDAwMDAsInJlYWQiOjYwMDAwMDAwMDAwMCwidXBkYXRlIjoxMjAwMDAwMDAwMDAwfX0="
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_project_service",
      "name": "run",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "disable_dependent_services": null,
            "disable_on_destroy": false,
            "id": "goiryoku-kojo/run.googleapis.com",
            "project": "goiryoku-kojo",
            "service": "run.googleapis.com",
            "timeouts": null
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoxMjAwMDAwMDAwMDAwLCJkZWxldGUiOjEyMDAwMDAwMDAwMDAsInJlYWQiOjYwMDAwMDAwMDAwMCwidXBkYXRlIjoxMjAwMDAwMDAwMDAwfX0="
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_service_account",
      "name": "functions_sa",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "account_id": "goiryoku-functions",
            "create_ignore_already_exists": null,
            "description": "",
            "disabled": false,
            "display_name": "Goiryoku Cloud Functions Service Account",
            "email": "goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
            "id": "projects/goiryoku-kojo/serviceAccounts/goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
            "member": "serviceAccount:goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
            "name": "projects/goiryoku-kojo/serviceAccounts/goiryoku-functions@goiryoku-kojo.iam.gserviceaccount.com",
            "project": "goiryoku-kojo",
            "timeouts": null,
            "unique_id": "105401226420456272330"
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjozMDAwMDAwMDAwMDB9fQ=="
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_storage_bucket",
      "name": "functions_bucket",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 2,
          "attributes": {
            "autoclass": [],
            "cors": [],
            "custom_placement_config": [],
            "default_event_based_hold": false,
            "effective_labels": {},
            "enable_object_retention": false,
            "encryption": [],
            "force_destroy": false,
            "id": "goiryoku-kojo-goiryoku-functions",
            "labels": {},
            "lifecycle_rule": [],
            "location": "ASIA-NORTHEAST1",
            "logging": [],
            "name": "goiryoku-kojo-goiryoku-functions",
            "project": "goiryoku-kojo",
            "project_number": 561096623466,
            "public_access_prevention": "inherited",
            "requester_pays": false,
            "retention_policy": [],
            "rpo": null,
            "self_link": "https://www.googleapis.com/storage/v1/b/goiryoku-kojo-goiryoku-functions",
            "soft_delete_policy": [
              {
                "effective_time": "2025-12-31T04:08:03.640Z",
                "retention_duration_seconds": 604800
              }
            ],
            "storage_class": "STANDARD",
            "terraform_labels": {},
            "timeouts": null,
            "uniform_bucket_level_access": true,
            "url": "gs://goiryoku-kojo-goiryoku-functions",
            "versioning": [],
            "website": []
          },
          "sensitive_attributes": [],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsInJlYWQiOjI0MDAwMDAwMDAwMCwidXBkYXRlIjoyNDAwMDAwMDAwMDB9LCJzY2hlbWFfdmVyc2lvbiI6IjIifQ=="
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_storage_bucket_object",
      "name": "generate_words_source",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "bucket": "goiryoku-kojo-goiryoku-functions",
            "cache_control": "",
            "content": null,
            "content_disposition": "",
            "content_encoding": "",
            "content_language": "",
            "content_type": "application/zip",
            "crc32c": "FFHD7w==",
            "customer_encryption": [],
            "detect_md5hash": "EXgGJVI/1C4VEY89KNxUVw==",
            "event_based_hold": false,
            "generation": 1767286799974215,
            "id": "goiryoku-kojo-goiryoku-functions-generate_words-11780625523fd42e15118f3d28dc5457.zip",
            "kms_key_name": "",
            "md5hash": "EXgGJVI/1C4VEY89KNxUVw==",
            "media_link": "https://storage.googleapis.com/download/storage/v1/b/goiryoku-kojo-goiryoku-functions/o/generate_words-11780625523fd42e15118f3d28dc5457.zip?generation=1767286799974215\u0026alt=media",
            "metadata": null,
            "name": "generate_words-11780625523fd42e15118f3d28dc5457.zip",
            "output_name": "generate_words-11780625523fd42e15118f3d28dc5457.zip",
            "retention": [],
            "self_link": "https://www.googleapis.com/storage/v1/b/goiryoku-kojo-goiryoku-functions/o/generate_words-11780625523fd42e15118f3d28dc5457.zip",
            "source": "./tmp/generate_words.zip",
            "storage_class": "STANDARD",
            "temporary_hold": false,
            "timeouts": null
          },
          "sensitive_attributes": [
            [
              {
                "type": "get_attr",
                "value": "content"
              }
            ]
          ],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoyNDAwMDAwMDAwMDAsImRlbGV0ZSI6MjQwMDAwMDAwMDAwLCJ1cGRhdGUiOjI0MDAwMDAwMDAwMH19",
          "dependencies": [
            "data.archive_file.generate_words_source",
            "google_storage_bucket.functions_bucket"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_storage_bucket_object",
      "name": "get_words_source",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "bucket": "goiryoku-kojo-goiryoku-functions",
            "cache_control": "",
            "content": null,
            "content_disposition": "",
            "content_encoding": "",
            "content_language": "",
            "content_type": "application/zip",
            "crc32c": "YNpb8A==",
            "customer_encryption": [],
            "detect_md5hash": "sXzkP4Xk7gDiMKcuRvvGjw==",
            "event_based_hold": false,
            "generation": 1767286800007098,
            "id": "goiryoku-kojo-goiryoku-functions-get_words-b17ce43f85e4ee00e230a72e46fbc68f.zip",
            "kms_key_name": "",
            "md5hash": "sXzkP4Xk7gDiMKcuRvvGjw==",
            "media_link": "https://storage.googleapis.com/download/storage/v1/b/goiryoku-kojo-goiryoku-functions/o/get_words-b17ce43f85e4ee00e230a72e46fbc68f.zip?generation=1767286800007098\u0026alt=media",
            "metadata": null,
            "name": "get_words-b17ce43f85e4ee00e230a72e46fbc68f.zip",
            "output_name": "get_words-b17ce43f85e4ee00e230a72e46fbc68f.zip",
            "retention": [],
            "self_link": "https://www.googleapis.com/storage/v1/b/goiryoku-kojo-goiryoku-functions/o/get_words-b17ce43f85e4ee00e230a72e46fbc68f.zip",
            "source": "./tmp/get_words.zip",
            "storage_class": "STANDARD",
            "temporary_hold": false,
            "timeouts": null
          },
          "sensitive_attributes": [
            [
              {
                "type": "get_attr",
                "value": "content"
              }
            ]
          ],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoyNDAwMDAwMDAwMDAsImRlbGV0ZSI6MjQwMDAwMDAwMDAwLCJ1cGRhdGUiOjI0MDAwMDAwMDAwMH19",
          "dependencies": [
            "data.archive_file.get_words_source",
            "google_storage_bucket.functions_bucket"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_storage_bucket_object",
      "name": "score_answers_source",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "bucket": "goiryoku-kojo-goiryoku-functions",
            "cache_control": "",
            "content": null,
            "content_disposition": "",
            "content_encoding": "",
            "content_language": "",
            "content_type": "application/zip",
            "crc32c": "5u52Xw==",
            "customer_encryption": [],
            "detect_md5hash": "7nVCGGNEoAXxoI85VeHMxw==",
            "event_based_hold": false,
            "generation": 1767286799944385,
            "id": "goiryoku-kojo-goiryoku-functions-score_answers-ee7542186344a005f1a08f3955e1ccc7.zip",
            "kms_key_name": "",
            "md5hash": "7nVCGGNEoAXxoI85VeHMxw==",
            "media_link": "https://storage.googleapis.com/download/storage/v1/b/goiryoku-kojo-goiryoku-functions/o/score_answers-ee7542186344a005f1a08f3955e1ccc7.zip?generation=1767286799944385\u0026alt=media",
            "metadata": null,
            "name": "score_answers-ee7542186344a005f1a08f3955e1ccc7.zip",
            "output_name": "score_answers-ee7542186344a005f1a08f3955e1ccc7.zip",
            "retention": [],
            "self_link": "https://www.googleapis.com/storage/v1/b/goiryoku-kojo-goiryoku-functions/o/score_answers-ee7542186344a005f1a08f3955e1ccc7.zip",
            "source": "./tmp/score_answers.zip",
            "storage_class": "STANDARD",
            "temporary_hold": false,
            "timeouts": null
          },
          "sensitive_attributes": [
            [
              {
                "type": "get_attr",
                "value": "content"
              }
            ]
          ],
          "identity_schema_version": 0,
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoyNDAwMDAwMDAwMDAsImRlbGV0ZSI6MjQwMDAwMDAwMDAwLCJ1cGRhdGUiOjI0MDAwMDAwMDAwMH19",
          "dependencies": [
            "data.archive_file.score_answers_source",
            "google_storage_bucket.functions_bucket"
          ]
        }
      ]
    }
  ],
  "check_results": null
}
